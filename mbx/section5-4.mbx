
<section xml:id="s_induction_bincoeffs">
<title>Binomial Coefficients Revisited</title>
<p>
The binomial coefficient <m>\binom{n}{k}</m> was originally defined in
terms of the factorial notation, and with our recursive definitions of
the factorial notation, we also have a complete and legally-correct
definition of binomial coefficients. The following recursive formula
provides an efficient computational scheme.
</p>
  
<p>
Let <m>n</m> and <m>k</m> be integers with <m>0\le k\le n</m>. If <m>k=0</m> or <m>k=n</m>, set
<m>\binom{n}{k}=1</m>. If <m>0\lt k\lt n</m>, set
</p>
  
<me>

\binom{n}{k}=\binom{n-1}{k-1}+\binom{n-1}{k}.

</me>
 
<p>
This recursion has a natural combinatorial interpretation. Both sides
count the number of <m>k</m>-element subsets of <m>\{1,2,\dots,n\}</m>, with the
right-hand side first grouping them into those which contain the
element<nbsp /><m>n</m> and then those which don't. The traditional form of
displaying this recursion is shown in <xref ref="fig_pascal" autoname="yes" />. This
pattern is called <q>Pascal's triangle.</q> Other than the <m>1</m>s at the
ends of each row, an entry of the triangle is determined by adding the
entry to the left and the entry to the right in the row above.
</p>
  <figure xml:id="fig_pascal" >
<caption>Pascal's Triangle </caption>
<table id="912cc90d4a2cbf6a9642b6846c8647e188b6db54" ><tr><td class='c'>
\amp  \amp    \amp    \amp    \amp    \amp    \amp    \amp   1\amp    \amp    \amp    \amp    \amp    \amp    \amp    \amp   </td></tr>
<tr><td class='c'>
\amp  \amp    \amp    \amp    \amp    \amp    \amp   1\amp    \amp   1\amp    \amp    \amp    \amp    \amp    \amp    \amp   </td></tr>
<tr><td class='c'>
\amp  \amp    \amp    \amp    \amp    \amp   1\amp    \amp   2\amp    \amp   1\amp    \amp    \amp    \amp    \amp    \amp   </td></tr>
<tr><td class='c'>
\amp   \amp    \amp    \amp    \amp   1\amp    \amp   3\amp    \amp   3\amp    \amp   1\amp    \amp    \amp    \amp    \amp   </td></tr>
<tr><td class='c'>
\amp   \amp    \amp    \amp   1\amp    \amp   4\amp    \amp   6\amp    \amp   4\amp    \amp   1\amp    \amp    \amp    \amp   </td></tr>
<tr><td class='c'>
\amp   \amp    \amp   1\amp    \amp   5\amp    \amp  10\amp    \amp  10\amp    \amp   5\amp    \amp   1\amp    \amp    \amp   </td></tr>
<tr><td class='c'>
\amp   \amp   1\amp    \amp   6\amp    \amp  15\amp    \amp  20\amp    \amp  15\amp    \amp   6\amp    \amp   1\amp    \amp   </td></tr>
<tr><td class='c'>
\amp  1\amp    \amp   7\amp    \amp  21\amp    \amp  35\amp    \amp  35\amp    \amp  21\amp    \amp   7\amp    \amp   1\amp  </td></tr>
<tr><td class='c'>
1\amp  \amp  8  \amp   \amp  28  \amp  \amp   56 \amp  \amp   70 \amp  \amp  56  \amp  \amp  28  \amp   \amp  8  \amp   \amp 1</td></tr>
</table> </figure>
  
<p>
Xing was intrigued by the fact that he now had two fundamentally
different ways to calculate binomial coefficients. One way
is to write <m>\binom{n}{m}=P(n,m)/(n-m)!</m> and just carry out
the specified arithmetic. The second way is to use the
recursion of Pascal's triangle, so that you are just performing
additions. So he experimented by writing a computer program
to calculate binomial coefficients, using a library that treats
big integers as strings. Which of the two ways do you think
proved to be faster when <m>n</m> say was between <m>1800</m> and <m>2000</m>
and <m>m</m> was around <m>800</m>?
</p>
 </section>